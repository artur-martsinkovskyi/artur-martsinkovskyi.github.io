---
layout: post
title: Vim in modernity - why and why not
description: Vim is old, but good. What is the Zen of it?
date: 2019-05-30
---
I am a Vim acolyte now. I haven't always been one. First I used simple Gedit but it started to raise frustration in me. It was too bare-bones and I needed to switch context over and over to do some simple tasks like rerunning the server, playing with the console, looking up logs.  I skipped to a more complicated and seemingly featurefull Rubymine. It suited me for some time, but I felt like something was off. It was almost like a burden was put on my neck. It worked well when properly set up, but it was big. Pretty big. Memory footprint was enormous for all the misses in code suggestions, for every piece of additional configuration that I needed to set up once something changed in my environment. The other problem was the language I was working with. Ruby is straight out unpredictable chaos at times. Virtually everything can be generated, deleted and redefined at runtime. Methods come and go, it is interpreted, so it is quite hard(almost impossible) to compose proper Go to  Definition, code suggestions and overall static analysis tool for it. After some time(and an incident when Rubymine devoured 16 gigs of RAM and broke) I left. My team lead was using Vim, so I decided to try it out. It was painful at first, but after about two weeks of sinking in the sea of cryptic commands and being frustrated with my mouse habits I started to feel something good. It was the start of enlightenment.

## Nothing alike

Vim is obviously a console editor(you can get a GUI version but it is not really needed). It runs in a terminal as any terminal program, so it can be stopped with Ctrl^Z and then brought back with `fg`. It(or its ancestors or variarions) is installed on virtually every UNIX-like system in the world and can run through `ssh`. You can edit multiple files at once using tabs and panes and traverse easily between them using only keyboard. It is modal. Its modes are insert, normal, visual, and command-line mode. It may scare you at first, but this is actually a feature, not an issue. I was always a bit frustrated with the fact that I need to use the mouse to go to an arbitrary point in the text to edit it, so I reach it, point at the needed place and then get back to the keyboard. Modes resolve the issue - in normal mode you traverse the text with the use of arrows or keys H, J, K, L and when you want to insert something you just go in the insert mode, do the job and get back to the normal mode. Command-line mode is used for commands like substitution, help, running shell commands, various custom scripts, etc. Commands of vim are mnemonics. `a` stands for append, `d` for delete, 0 is the begginning of the line, $ is the end. They can be combined in various ways and after some time a user forgets about their existence, they are basically on the tips of his fingers. It is like cycling(if a bycicle could be controlled by neurointerface and fly you to the moon). Once you know how to do it, is is done instinctively.

## Opium of minimal optimum

So, why do I use Vim over all those shiny editors and IDEs? It is minimalistic. Just enough to do the job. No overcomplicated tools, no cascading context menus, no overgrown memory footprint and caching, no pollution of your project library with editor tempiles. Just you and your terminal and the Art of Vim. You don't switch the context every time you use the mouse to point at something, you stay at your keyboard and you can reach everything with it. It allows you to focus and concenrate on the job, to meditate over your code and change it with a slight flip of your fingers. It is faster to move between files and faster to type. I don't need all those diff editors, GUI for git, tools for every integration like Puppet, Chef or loggers when I have my console. It shifts the focus on what is important. When you are in Vim, you are in the terminal, so a single Ctrl^Z gets you back in the context so you run the commands you need and get back to the editor. It is a Zen practice of its own, monotonous accurate movements, focus on one thing and absence of unneccesary. Once you configured it - you don't really need to change a thing(the fatigue of configuration I had with Emacs was driving me mad because I was configuring stuff more than doing actuall job, even though it was a delightful experience). Learning Vim is a never ending experience, you can combine commands and its capabilities in a long range of ways, so it becomes something like the martial art with an infinte field of capabilities.

## Elegant weapon for a more civilized age

Vim is old. It was created in 1991 and and its predecessor vi was created in 1976. It has a vast and vibrant community that writes plugins, updates it and even rewrites it as with Neovim or embeds it in other editors like Vim mode in JetBrains products or evil mode for Emacs. It has a cultural influence on the industry because of what it is - an elgant instrument for editing the code. It is elegant and easy to use once you embrace its vibe. It suits and I like to use it for almost all of my programming tasks. But would I use it if I was writing Java? C##? C++? Those languages can facilitate much from the static analysis tools,  precompilation and their ecosystems require quite a lot of effort to start something from scratch. Configuration files, orchestration, containers and application servers - those things are interconnected with IDEs and even though it is possible to handle all of that in the console mostly there is not much sense to do so. Once I am using scripting languages or something with small overhead - I'll go with Vim. But if IDE can grant me better capabilities and save time - I will go with it and use Vim-mode plugin. Even though it will break full immersion, it is better to choose the tools for the job, not just the tool you like. I dream that someone would create something with Vim interface and all facilities of the modern editor, but for now it is just a dream. Will it come true some day?

P.S. This article was also written in Vim :)

